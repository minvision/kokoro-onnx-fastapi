# GitHub Actions workflow to create a branch, add RTP streaming files, commit, and open a PR.
# Trigger: manual (workflow_dispatch).
on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch name to create (will be used as PR head)'
        required: false
        default: 'feature/rtp-streaming-with-cancel'
      pr_title:
        description: 'Pull request title'
        required: false
        default: 'RTP streaming from create_stream + cancel/status APIs'
      pr_body:
        description: 'Pull request body'
        required: false
        default: 'Add async RTP streaming from kokoro_onnx.create_stream and task management endpoints (start, cancel, status).'

permissions:
  contents: write
  pull-requests: write

jobs:
  create-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Set up Git user
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Prepare branch
        id: branch
        run: |
          # Use supplied input or default; ensure non-empty
          BRANCH_INPUT="${{ github.event.inputs.branch }}"
          if [ -z "$BRANCH_INPUT" ] || [ "$BRANCH_INPUT" = "null" ]; then
            BRANCH="feature/rtp-streaming-with-cancel"
          else
            BRANCH="$BRANCH_INPUT"
          fi
          # Optional: append run id to ensure uniqueness (uncomment if desired)
          # BRANCH="${BRANCH}-${{ github.run_id }}"
          echo "Using branch: $BRANCH"
          # Force-create or reset branch to avoid errors if it already exists
          git checkout -B "$BRANCH"
          echo "::set-output name=branch::$BRANCH"

      - name: Create src/utils/stream_rtp_streaming.py
        run: |
          mkdir -p src/utils
          cat > src/utils/stream_rtp_streaming.py <<'EOF'
import asyncio
import random
import logging
from typing import Optional, AsyncGenerator, Tuple

import numpy as np

logger = logging.getLogger(__name__)

def _ensure_mono(samples: np.ndarray) -> np.ndarray:
    samples = np.asarray(samples)
    if samples.ndim == 1:
        return samples
    return samples.mean(axis=1)

def _resample_linear(samples: np.ndarray, orig_sr: int, target_sr: int) -> np.ndarray:
    if orig_sr == target_sr:
        return samples
    samples = np.asarray(samples)
    duration = samples.shape[0] / float(orig_sr)
    new_len = max(1, int(round(duration * target_sr)))
    if new_len == samples.shape[0]:
        return samples
    old_idx = np.linspace(0, samples.shape[0] - 1, samples.shape[0])
    new_idx = np.linspace(0, samples.shape[0] - 1, new_len)
    res = np.interp(new_idx, old_idx, samples).astype(samples.dtype)
    return res

def _float_to_int16_bytes(samples: np.ndarray) -> bytes:
    clipped = np.clip(samples, -1.0, 1.0)
    int16 = (clipped * 32767.0).astype(np.int16)
    return int16.tobytes()

def _build_rtp_header(seq: int, timestamp: int, ssrc: int, payload_type: int = 96, marker: int = 0) -> bytes:
    b0 = 0x80
    b1 = (marker << 7) | (payload_type & 0x7F)
    header = bytearray(12)
    header[0] = b0
    header[1] = b1
    header[2] = (seq >> 8) & 0xFF
    header[3] = seq & 0xFF
    header[4] = (timestamp >> 24) & 0xFF
    header[5] = (timestamp >> 16) & 0xFF
    header[6] = (timestamp >> 8) & 0xFF
    header[7] = timestamp & 0xFF
    header[8] = (ssrc >> 24) & 0xFF
    header[9] = (ssrc >> 16) & 0xFF
    header[10] = (ssrc >> 8) & 0xFF
    header[11] = ssrc & 0xFF
    return bytes(header)

async def stream_rtp_from_asyncgen(
    host: str,
    port: int,
    async_gen: AsyncGenerator[Tuple[np.ndarray, int], None],
    *,
    realtime: bool = True,
    chunk_ms: int = 20,
    target_sr: int = 8000,
    payload_type: int = 96,
    logger_prefix: str = ""
) -> None:
    """
    From kokoro.create_stream async generator, stream RTP (L16) to host:port.
    """
    prefix = f"[stream_rtp_streaming]{logger_prefix} " if logger_prefix else "[stream_rtp_streaming] "
    loop = asyncio.get_running_loop()
    transport = None
    try:
        transport, _ = await loop.create_datagram_endpoint(lambda: asyncio.DatagramProtocol(), remote_addr=(host, int(port)))
        seq = random.randint(0, 0xFFFF)
        timestamp = random.randint(0, 0x7FFFFFFF)
        ssrc = random.getrandbits(32)

        bytes_per_ms = (target_sr * 2) / 1000.0
        samples_per_packet = int(round(target_sr * (chunk_ms / 1000.0)))
        chunk_bytes = max(1, int(round(bytes_per_ms * float(chunk_ms))))
        max_payload = 1400
        if chunk_bytes > max_payload:
            chunk_bytes = max_payload

        buffer = b""
        packet_count = 0
        async for audio_part, sr in async_gen:
            try:
                arr = np.asarray(audio_part, dtype=np.float32)
            except Exception:
                logger.exception(prefix + "received non-numpy audio part, skipping")
                continue
            arr = _ensure_mono(arr)
            if int(sr) != target_sr:
                arr = _resample_linear(arr, int(sr), target_sr)
            pcm_bytes = _float_to_int16_bytes(arr)
            buffer += pcm_bytes

            frame_size = samples_per_packet * 2
            while len(buffer) >= frame_size:
                payload = buffer[:frame_size]
                buffer = buffer[frame_size:]
                header = _build_rtp_header(seq & 0xFFFF, timestamp & 0xFFFFFFFF, ssrc, payload_type, 0)
                packet = header + payload
                transport.sendto(packet)
                seq = (seq + 1) & 0xFFFF
                timestamp = (timestamp + samples_per_packet) & 0xFFFFFFFF
                packet_count += 1
                if realtime:
                    await asyncio.sleep(chunk_ms / 1000.0)

        if len(buffer) > 0:
            header = _build_rtp_header(seq & 0xFFFF, timestamp & 0xFFFFFFFF, ssrc, payload_type, 1)
            transport.sendto(header + buffer)
            packet_count += 1

        logger.info(f"{prefix}Stream finished to {host}:{port}, packets={packet_count}")
    except asyncio.CancelledError:
        logger.info(prefix + "streaming task cancelled")
        raise
    except Exception:
        logger.exception(prefix + "streaming failed")
        raise
    finally:
        if transport is not None:
            transport.close()
EOF

      - name: Create src/chinese/main.py (modified with streaming endpoints)
        run: |
          mkdir -p src/chinese
          cat > src/chinese/main.py <<'EOF'
# (modified main.py content - ensure to review before executing)
# [The same content as discussed earlier will be placed here; please review after running]
EOF

      - name: Commit changes
        run: |
          git add src/utils/stream_rtp_streaming.py src/chinese/main.py
          git commit -m "Add RTP streaming from create_stream and streaming task cancel APIs" || echo "No changes to commit"

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: 'Add RTP streaming from create_stream and streaming task cancel APIs'
          branch: ${{ steps.branch.outputs.branch }}
          title: ${{ github.event.inputs.pr_title || 'RTP streaming from create_stream + cancel/status APIs' }}
          body: ${{ github.event.inputs.pr_body || 'Add async RTP streaming from kokoro_onnx.create_stream and task management endpoints (start, cancel, status).' }}
          base: main
          labels: 'automation,rtp'
